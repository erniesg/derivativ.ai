"""
Document Storage Service.
Orchestrates complete document storage workflows including export and R2 storage.
"""

import contextlib
import logging
from pathlib import Path
from typing import Any, Optional
from uuid import UUID, uuid4

from src.models.document_models import DocumentStructure
from src.models.stored_document_models import (
    DocumentFile,
    StoredDocumentMetadata,
)
from src.repositories.document_storage_repository import DocumentStorageRepository
from src.services.document_export_service import DocumentExportService
from src.services.document_version_service import DocumentVersionService
from src.services.r2_storage_service import R2StorageService

logger = logging.getLogger(__name__)


class DocumentStorageError(Exception):
    """Raised when document storage operations fail."""

    pass


class DocumentStorageService:
    """Service for complete document storage workflows."""

    def __init__(
        self,
        r2_service: R2StorageService,
        repository: DocumentStorageRepository,
        export_service: Optional[DocumentExportService] = None,
    ):
        """
        Initialize document storage service.

        Args:
            r2_service: R2 storage service for file operations
            repository: Repository for database operations
            export_service: Document export service (creates new if None)
        """
        self.r2_service = r2_service
        self.repository = repository
        self.export_service = export_service or DocumentExportService()
        self.version_service = DocumentVersionService()

    async def store_generated_document(
        self,
        document: DocumentStructure,
        session_id: UUID,
        metadata: dict[str, Any],
        export_formats: list[str] = None,
        create_dual_versions: bool = True,
    ) -> dict[str, Any]:
        """
        Store a generated document with export and file upload.

        Args:
            document: Generated document structure
            session_id: Generation session ID
            metadata: Additional metadata for storage
            export_formats: List of formats to export (pdf, docx, html)
            create_dual_versions: Whether to create student/teacher versions

        Returns:
            Dictionary with storage result information

        Raises:
            DocumentStorageError: If storage operation fails
        """
        if export_formats is None:
            export_formats = ["pdf"]

        try:
            document_id = uuid4()
            stored_files = []

            logger.info(f"Starting document storage workflow for: {document.title}")

            # Step 1: Create document metadata
            doc_metadata = StoredDocumentMetadata(
                id=document_id,
                session_id=session_id,
                title=document.title,
                document_type=document.document_type.value,
                detail_level=document.detail_level.value if document.detail_level else None,
                topic=metadata.get("topic"),
                grade_level=metadata.get("grade_level"),
                estimated_duration=document.estimated_duration,
                total_questions=document.total_questions,
                status="generating",
                tags=metadata.get("tags", []),
                search_content="",  # Will be auto-generated by database trigger
            )

            # Step 2: Save document metadata
            await self.repository.save_document_metadata(doc_metadata)

            try:
                # Step 3: Export document in requested formats
                if create_dual_versions and document.document_type.value == "worksheet":
                    # Create student and teacher versions
                    for format_type in export_formats:
                        version_files = await self.export_service.export_worksheet_both_versions(
                            document, format_type
                        )

                        for version, file_path in version_files.items():
                            file_info = await self._upload_and_register_file(
                                document_id, file_path, format_type, version
                            )
                            stored_files.append(file_info)
                else:
                    # Single version export
                    for format_type in export_formats:
                        if format_type == "pdf":
                            file_path = await self.export_service.export_to_pdf(document)
                        elif format_type == "docx":
                            file_path = await self.export_service.export_to_docx(document)
                        elif format_type == "html":
                            file_path = await self.export_service.export_to_html(document)
                        else:
                            raise DocumentStorageError(f"Unsupported export format: {format_type}")

                        file_info = await self._upload_and_register_file(
                            document_id, file_path, format_type, "combined"
                        )
                        stored_files.append(file_info)

                # Step 4: Update document status to exported
                await self.repository.update_document_status(document_id, "exported")

                logger.info(
                    f"Successfully stored document {document_id} with {len(stored_files)} files"
                )

                return {
                    "success": True,
                    "document_id": document_id,
                    "file_count": len(stored_files),
                    "files": stored_files,
                    "total_size": sum(f.file_size for f in stored_files),
                }

            except Exception as e:
                # Update status to failed if export/upload fails
                await self.repository.update_document_status(
                    document_id, "failed", {"error_message": str(e)}
                )
                raise

        except Exception as e:
            logger.error(f"Failed to store document: {e}")
            raise DocumentStorageError(f"Failed to store document: {e}")

    async def retrieve_document_file(self, file_key: str) -> dict[str, Any]:
        """
        Retrieve document file content from R2 storage.

        Args:
            file_key: R2 storage key for the file

        Returns:
            Dictionary with file content and metadata

        Raises:
            DocumentStorageError: If retrieval fails
        """
        try:
            result = await self.r2_service.download_file(file_key)
            return result

        except Exception as e:
            logger.error(f"Failed to retrieve document file {file_key}: {e}")
            raise DocumentStorageError(f"Failed to retrieve document file: {e}")

    async def delete_document_and_files(self, document_id: UUID) -> dict[str, Any]:
        """
        Delete document and all associated files.

        Args:
            document_id: Document ID to delete

        Returns:
            Dictionary with deletion result

        Raises:
            DocumentStorageError: If deletion fails
        """
        try:
            # Get document and files
            stored_document = await self.repository.retrieve_document_by_id(document_id)
            if not stored_document:
                raise DocumentStorageError(f"Document not found: {document_id}")

            deleted_files = []
            failed_deletions = []

            # Delete files from R2
            for file_info in stored_document.files:
                try:
                    await self.r2_service.delete_file(file_info.file_key)
                    deleted_files.append(file_info.file_key)
                except Exception as e:
                    logger.warning(f"Failed to delete file {file_info.file_key}: {e}")
                    failed_deletions.append({"file_key": file_info.file_key, "error": str(e)})

            # Soft delete document in database
            await self.repository.soft_delete_document(document_id)

            logger.info(f"Deleted document {document_id} and {len(deleted_files)} files")

            return {
                "success": True,
                "document_id": document_id,
                "deleted_files": len(deleted_files),
                "failed_deletions": failed_deletions,
            }

        except Exception as e:
            logger.error(f"Failed to delete document {document_id}: {e}")
            raise DocumentStorageError(f"Failed to delete document: {e}")

    async def update_document_status(
        self, document_id: UUID, status: str, metadata: Optional[dict] = None
    ) -> bool:
        """
        Update document status and metadata.

        Args:
            document_id: Document ID to update
            status: New status value
            metadata: Optional metadata to update

        Returns:
            True if update successful

        Raises:
            DocumentStorageError: If update fails
        """
        try:
            return await self.repository.update_document_status(document_id, status, metadata)

        except Exception as e:
            logger.error(f"Failed to update document status: {e}")
            raise DocumentStorageError(f"Failed to update document status: {e}")

    async def generate_file_access_url(self, file_key: str, expiration: int = 3600) -> str:
        """
        Generate presigned URL for file access.

        Args:
            file_key: R2 storage key for the file
            expiration: URL expiration time in seconds

        Returns:
            Presigned URL string

        Raises:
            DocumentStorageError: If URL generation fails
        """
        try:
            return await self.r2_service.generate_presigned_url(file_key, expiration)

        except Exception as e:
            logger.error(f"Failed to generate access URL for {file_key}: {e}")
            raise DocumentStorageError(f"Failed to generate access URL: {e}")

    async def export_existing_document(
        self, document_id: UUID, formats: list[str], create_dual_versions: bool = False
    ) -> dict[str, Any]:
        """
        Export an existing stored document to additional formats.

        Args:
            document_id: Document ID to export
            formats: List of formats to export
            create_dual_versions: Whether to create dual versions

        Returns:
            Dictionary with export result

        Raises:
            DocumentStorageError: If export fails
        """
        try:
            # Retrieve stored document
            stored_document = await self.repository.retrieve_document_by_id(document_id)
            if not stored_document:
                raise DocumentStorageError(f"Document not found: {document_id}")

            # Update status to exporting
            await self.repository.update_document_status(document_id, "exporting")

            new_files = []

            try:
                # Check which formats already exist
                existing_formats = {f.file_format for f in stored_document.files}
                formats_to_export = [f for f in formats if f not in existing_formats]

                if not formats_to_export:
                    logger.info(f"All requested formats already exist for document {document_id}")
                    return {
                        "success": True,
                        "document_id": document_id,
                        "new_files": 0,
                        "message": "All formats already exist",
                    }

                # TODO: Reconstruct DocumentStructure from stored metadata
                # For now, this would require additional logic to recreate the document
                # This is a placeholder for the export logic

                logger.info(f"Would export document {document_id} to formats: {formats_to_export}")

                # Update status back to exported
                await self.repository.update_document_status(document_id, "exported")

                return {
                    "success": True,
                    "document_id": document_id,
                    "new_files": len(new_files),
                    "formats_exported": formats_to_export,
                }

            except Exception as e:
                # Update status to failed if export fails
                await self.repository.update_document_status(
                    document_id, "failed", {"export_error": str(e)}
                )
                raise

        except Exception as e:
            logger.error(f"Failed to export existing document {document_id}: {e}")
            raise DocumentStorageError(f"Failed to export existing document: {e}")

    async def _upload_and_register_file(
        self, document_id: UUID, file_path: Path, file_format: str, version: str
    ) -> DocumentFile:
        """
        Upload file to R2 and register in database.

        Args:
            document_id: Parent document ID
            file_path: Local file path to upload
            file_format: File format extension
            version: Document version (student, teacher, combined)

        Returns:
            DocumentFile object with upload information

        Raises:
            DocumentStorageError: If upload or registration fails
        """
        try:
            # Read file content
            file_content = file_path.read_bytes()
            file_size = len(file_content)

            # Generate R2 storage key
            r2_file_key = self.r2_service.generate_file_key(
                str(document_id), "generated", file_format, version
            )

            # Upload to R2
            upload_result = await self.r2_service.upload_file(
                file_content,
                r2_file_key,
                metadata={
                    "document_id": str(document_id),
                    "version": version,
                    "format": file_format,
                    "upload_timestamp": str(Path(file_path).stat().st_mtime),
                },
            )

            # Create file record
            file_record = DocumentFile(
                id=uuid4(),
                document_id=document_id,
                file_key=r2_file_key,
                file_format=file_format,
                version=version,
                file_size=file_size,
                content_type=self._detect_content_type(file_format),
                r2_metadata={
                    "upload_id": upload_result.get("upload_id"),
                    "bucket": upload_result.get("bucket"),
                    "upload_timestamp": upload_result.get("upload_timestamp"),
                },
            )

            # Save file record to database
            await self.repository.save_document_file(file_record)

            # Clean up temporary file
            with contextlib.suppress(Exception):
                file_path.unlink()

            logger.info(f"Successfully uploaded and registered file: {r2_file_key}")
            return file_record

        except Exception as e:
            logger.error(f"Failed to upload and register file: {e}")
            raise DocumentStorageError(f"Failed to upload and register file: {e}")

    def _detect_content_type(self, file_format: str) -> str:
        """
        Detect MIME content type from file format.

        Args:
            file_format: File format extension

        Returns:
            MIME content type string
        """
        content_type_map = {
            "pdf": "application/pdf",
            "docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            "html": "text/html",
            "txt": "text/plain",
            "json": "application/json",
            "png": "image/png",
            "jpg": "image/jpeg",
            "svg": "image/svg+xml",
        }

        return content_type_map.get(file_format, "application/octet-stream")

    async def get_document_storage_stats(self) -> dict[str, Any]:
        """
        Get document storage statistics.

        Returns:
            Dictionary with storage statistics

        Raises:
            DocumentStorageError: If statistics retrieval fails
        """
        try:
            return await self.repository.get_document_statistics()

        except Exception as e:
            logger.error(f"Failed to get storage statistics: {e}")
            raise DocumentStorageError(f"Failed to get storage statistics: {e}")

    async def cleanup_failed_documents(self, max_age_hours: int = 24) -> dict[str, Any]:
        """
        Clean up documents that failed to generate or export.

        Args:
            max_age_hours: Maximum age of failed documents to keep

        Returns:
            Dictionary with cleanup results

        Raises:
            DocumentStorageError: If cleanup fails
        """
        try:
            from datetime import datetime, timedelta

            cutoff_date = datetime.now() - timedelta(hours=max_age_hours)

            # This would require additional query logic to find failed documents
            # For now, use the existing cleanup method
            deleted_count = await self.repository.cleanup_old_documents(cutoff_date)

            logger.info(f"Cleaned up {deleted_count} old documents")

            return {
                "success": True,
                "deleted_documents": deleted_count,
                "cutoff_date": cutoff_date.isoformat(),
            }

        except Exception as e:
            logger.error(f"Failed to cleanup failed documents: {e}")
            raise DocumentStorageError(f"Failed to cleanup failed documents: {e}")
